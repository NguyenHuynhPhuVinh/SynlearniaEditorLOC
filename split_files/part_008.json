      "configure-prompts": "Configurar archivos de indicación...",
      "configure-prompts.short": "Archivos de mensajes",
      "run-prompt-in-new-chat.capitalized": "Ejecutar indicación en un chat nuevo",
      "run-prompt.capitalized": "Ejecutar símbolo del sistema en el chat actual",
      "run-prompt.capitalized.ellipses": "Ejecutar indicación..."
    },
    "vs/workbench/contrib/chat/browser/promptSyntax/saveToPromptAction": {
      "workbench.actions.save-to-prompt.label": "Guardar sesión de chat en un archivo de indicación"
    },
    "vs/workbench/contrib/chat/browser/tools/toolSetsContribution": {
      "bad_name1": "Nombre de archivo no válido",
      "bad_name2": "\"{0}\" no es un nombre de archivo válido",
      "chat.configureToolSets": "Configurar conjuntos de herramientas...",
      "chat.configureToolSets.add": "Crear nuevo archivo de conjuntos de herramientas...",
      "chat.configureToolSets.placeholder": "Seleccione un conjunto de herramientas para configurar",
      "chat.configureToolSets.short": "Conjuntos de herramientas",
      "input.placeholder": "Escriba el nombre de archivo de conjuntos de herramientas",
      "schema.default": "Conjunto de herramientas vacío",
      "schema.description": "Breve descripción de este conjunto de herramientas.",
      "schema.icon": "Icono que se usará para este conjunto de herramientas en la interfaz de usuario. Usa la sintaxis \"\\$(name)\", como \"\\$(zap)\"",
      "schema.tools": "Lista de herramientas o conjuntos de herramientas que se incluirán en este conjunto de herramientas. No puede estar vacío y debe hacer referencia a las herramientas como se hace referencia en las indicaciones.",
      "tool.description": "{1} ({0})\r\n\r\n{2}",
      "toolsetSchema.json": "Configuración de conjuntos de herramientas de usuario"
    },
    "vs/workbench/contrib/chat/browser/viewsWelcome/chatViewsWelcomeHandler": {
      "chatViewsWelcome.content": "Contenido del mensaje de bienvenida. El primer vínculo de comando se representará como un botón.",
      "chatViewsWelcome.icon": "Icono del mensaje de bienvenida.",
      "chatViewsWelcome.title": "Título del mensaje de bienvenida.",
      "chatViewsWelcome.when": "Condición cuando se muestra el mensaje de bienvenida.",
      "vscode.extension.contributes.chatViewsWelcome": "Aporta un mensaje de bienvenida a una vista de chat"
    },
    "vs/workbench/contrib/chat/browser/viewsWelcome/chatViewWelcomeController": {
      "agentModeSubtitle": "Modo de agente",
      "runPromptTitle": "Indicación sugerida: {0}",
      "suggestedPromptAriaLabel": "Indicación sugerida: {0}"
    },
    "vs/workbench/contrib/chat/common/chatColors": {
      "chat.avatarBackground": "Color de fondo de un avatar de chat.",
      "chat.avatarForeground": "Color de primer plano de un avatar de chat.",
      "chat.editedFileForeground": "Color de primer plano de un archivo editado por chat en la lista de archivos editados.",
      "chat.linesAddedForeground": "Color de primer plano de las líneas añadidas en la cápsula del bloque de código de chat.",
      "chat.linesRemovedForeground": "Color de primer plano de las líneas eliminadas en la cápsula del bloque de código de chat.",
      "chat.requestBackground": "Color de fondo de una solicitud de chat.",
      "chat.requestBorder": "Color del borde de una solicitud de chat.",
      "chat.requestBubbleBackground": "Color de fondo de la burbuja de solicitud de chat.",
      "chat.requestBubbleHoverBackground": "Color de fondo de la burbuja de solicitud de chat al pasar el ratón por encima.",
      "chat.requestCodeBorder": "Color de borde de los bloques de código dentro de la burbuja de solicitud de chat.",
      "chat.slashCommandBackground": "Color de fondo de un comando de barra oblicua de chat.",
      "chat.slashCommandForeground": "Color de primer plano de un comando de barra oblicua de chat.",
      "chatCheckpointSeparator": "Color del separador de punto de control del chat."
    },
    "vs/workbench/contrib/chat/common/chatContextKeys": {
      "chatEditApplied": "True cuando se han aplicado las ediciones de texto del chat.",
      "chatEditingCanRedo": "True cuando es posible rehacer una interacción en el panel de edición.",
      "chatEditingCanUndo": "True cuando es posible deshacer una interacción en el panel de edición.",
      "chatEditingHasToolConfirmation": "True cuando hay una confirmación de herramienta presente.",
      "chatExtensionInvalid": "True cuando la extensión de chat instalada no es válida y debe actualizarse.",
      "chatHasCustomChatModes": "Es verdadero cuando el chat tiene modos de chat personalizados disponibles.",
      "chatHasFileAttachments": "Es true cuando el chat tiene datos adjuntos de archivo.",
      "chatInEmptyStateWithHistoryEnabled": "True cuando el historial de estado vacío del chat está habilitado Y el chat está en estado vacío.",
      "chatIsActiveSession": "Es true cuando la sesión de chat está activa actualmente (no se puede eliminar).",
      "chatIsEnabled": "True cuando el chat está habilitado porque se activa un participante de chat predeterminado con una implementación.",
      "chatIsHistoryItem": "True cuando el elemento de sesión de chat es del historial.",
      "chatItemId": "Id. del elemento de chat.",
      "chatLastItemId": "Id. del último elemento de chat.",
      "chatMode": "La \"variante\" del modo de chat actual: agente para modos personalizados.",
      "chatModelsAreUserSelectable": "True cuando el usuario puede seleccionar manualmente el modelo de chat.",
      "chatPanelExtensionParticipantRegistered": "True cuando se registra un participante de chat predeterminado para el panel desde una extensión.",
      "chatPanelLocation": "Ubicación del panel de chat.",
      "chatParticipantRegistered": "True cuando se registra un participante de chat predeterminado para el panel.",
      "chatPromptFileAttachedContextDescription": "Es true cuando el chat tiene un archivo de indicación adjunto.",
      "chatRemoteJobCreating": "Verdadero cuando se crea un trabajo de agente de codificación remoto.",
      "chatRequest": "El elemento de chat es una solicitud",
      "chatResponse": "El elemento de chat es una respuesta.",
      "chatResponseErrored": "Es True cuando la respuesta del chat produjo un error.",
      "chatResponseFiltered": "Es true cuando el servidor filtró la respuesta del chat.",
      "chatResponseSupportsIssueReporting": "Es verdadero cuando la respuesta de chat actual admite informes de problemas.",
      "chatSessionResponseDetectedAgentOrCommand": "Cuando se detectó automáticamente el agente o el comando",
      "chatSessionType": "Tipo del elemento de sesión de chat actual.",
      "chatSkipRequestInProgressMessage": "True cuando se debe omitir el mensaje de solicitud de chat en curso.",
      "chatToolCount": "Número de herramientas disponibles en el modo de chat actual.",
      "chatToolGroupingThreshold": "Número de herramientas a partir del cual comenzamos a realizar la agrupación virtual.",
      "enableRemoteCodingAgentPromptFileOverlay": "Si la característica de superposición de archivos de petición de mensajes del agente de codificación remota está habilitada",
      "filePartOfEditSession": "Verdadero cuando el widget de chat está dentro de un archivo con una edición de sesión.",
      "hasRemoteCodingAgent": "Si hay algún agente de codificación remoto disponible",
      "inChat": "es true cuando el foco está en el widget del chat; en caso contrario, es false.",
      "inChatEditor": "Indica si el foco está en el editor de chat.",
      "inInteractiveInput": "es true cuando el foco está en la entrada del chat; en caso contrario, es false.",
      "inQuickChat": "Es true cuando la interfaz de usuario de chat rápido tiene el foco; de lo contrario, es false.",
      "interactiveInputHasFocus": "True cuando la entrada de chat tiene el foco.",
      "interactiveInputHasText": "True cuando la entrada de chat tiene texto.",
      "interactiveSessionCurrentlyEditing": "True cuando se está editando la solicitud actual.",
      "interactiveSessionCurrentlyEditingInput": "True cuando se está editando la entrada de solicitud actual en la parte inferior.",
      "interactiveSessionRequestInProgress": "Es true cuando la solicitud actual aún está en curso.",
      "interactiveSessionResponseVote": "Cuando la respuesta ha sido votada a favor, se establece en \"up\". Cuando se ha votado en contra, se establece como \"down\". En caso contrario, será una cadena vacía.",
      "lockedToCodingAgent": "True cuando el widget de chat está bloqueado en la sesión del agente de codificación.",
      "toolsCount": "El recuento de herramientas disponibles en el chat.",
      "withinEditSessionDiff": "Verdadero cuando el widget de chat se envía al chat de edición de sesión."
    },
    "vs/workbench/contrib/chat/common/chatEditingService": {
      "chatEditingAgentSupportsReadonlyReferences": "Si el agente de edición de chat admite referencias de solo lectura (temporales)",
      "chatEditingWidgetFileState": "Estado actual del archivo en el widget de edición del chat"
    },
    "vs/workbench/contrib/chat/common/chatModel": {
      "codeCitation": "Código similar encontrado con 1 tipo de licencia",
      "codeCitations": "Código similar encontrado con {0} tipos de licencias",
      "copyrightContentRetry": "Respuesta eliminada debido a una posible coincidencia con el código público, reintentando con la indicación modificada.",
      "editsSummary": "Se realizaron cambios.",
      "filteredContentRetry": "Respuesta eliminada debido a los filtros de seguridad de contenido, reintentando con la indicación modificada."
    },
    "vs/workbench/contrib/chat/common/chatModes": {
      "agentDescription": "Proporcione instrucciones.",
      "chatDescription": "Formule una pregunta.",
      "editsDescription": "Editar archivos."
    },
    "vs/workbench/contrib/chat/common/chatProgressTypes/chatToolInvocation": {
      "toolInvocationMessage": "Usando {0}"
    },
    "vs/workbench/contrib/chat/common/chatServiceImpl": {
      "chat.startMcpServers": "Iniciar servidores MCP",
      "emptyResponse": "El proveedor devolvió una respuesta nula",
      "newChat": "Nuevo chat"
    },
    "vs/workbench/contrib/chat/common/chatSessionStore": {
      "join.chatSessionStore": "Guardando el historial de chats"
    },
    "vs/workbench/contrib/chat/common/chatVariableEntries": {
      "chat.attachment.problems.all": "Todos los problemas",
      "chat.attachment.problems.inFile": "Problemas en {0}"
    },
    "vs/workbench/contrib/chat/common/languageModels": {
      "vscode.extension.contributes.languageModelChatProviders": "Contribuye con proveedores de chat de modelos de lenguaje de un proveedor específico.",
      "vscode.extension.contributes.languageModels.displayName": "Nombre para mostrar del proveedor de chat del modelo de lenguaje.",
      "vscode.extension.contributes.languageModels.emptyVendor": "El campo de proveedor no puede estar vacío.",
      "vscode.extension.contributes.languageModels.managementCommand": "Un comando para administrar el proveedor de chat del modelo de lenguaje, por ejemplo, \"Administrar modelos de Copilot\". Se utiliza en el selector de modelos de chat. Si no se proporciona, no se mostrará un icono de engranaje durante la selección del proveedor.",
      "vscode.extension.contributes.languageModels.vendor": "Un proveedor único global del proveedor de chat del modelo de lenguaje.",
      "vscode.extension.contributes.languageModels.vendorAlreadyRegistered": "El proveedor \"{0}\" ya está registrado y no puede registrarse dos veces",
      "vscode.extension.contributes.languageModels.whitespaceVendor": "El campo de proveedor no puede empezar ni terminar con espacios en blanco."
    },
    "vs/workbench/contrib/chat/common/languageModelStats": {
      "Language Models": "Copilot",
      "chat": "chat",
      "languageModels": "El lenguaje modela las estadísticas de uso de esta extensión."
    },
    "vs/workbench/contrib/chat/common/languageModelToolsService": {
      "builtin": "Integrado",
      "ext": "Extensión: {0}",
      "mcp": "Servidor MCP: {0}",
      "user": "Definido por el usuario"
    },
    "vs/workbench/contrib/chat/common/modelPicker/modelPickerWidget": {
      "chat.modelPicker.other": "Otros modelos"
    },
    "vs/workbench/contrib/chat/common/promptSyntax/computeAutomaticInstructions": {
      "instruction.file.reason.agentsmd": "Se adjunta automáticamente porque la configuración {0} está habilitada",
      "instruction.file.reason.allFiles": "Adjunto automáticamente como patrón es **",
      "instruction.file.reason.copilot": "Se adjunta automáticamente porque la configuración {0} está habilitada",
      "instruction.file.reason.referenced": "Referencia de {0}",
      "instruction.file.reason.specificFile": "Adjunto automáticamente como patrón {0} coincide con {1}"
    },
    "vs/workbench/contrib/chat/common/promptSyntax/languageProviders/promptHeaderHovers": {
      "modelFamily": "- Familia: {0}",
      "modelName": "- Nombre: {0}",
      "modelVendor": "- Proveedor: {0}",
      "promptHeader.instructions.applyToRange": "Uno o varios patrones globales (separados por comas) que describen los archivos a los que se aplican las instrucciones. Según estos patrones, el archivo se incluye automáticamente en la solicitud cuando el contexto contiene un archivo que coincide con uno o varios de estos patrones. Utilice `**` cuando desee que este archivo se agregue siempre.\r\nEjemplo: **/*.ts, **/*.js, client/**",
      "promptHeader.instructions.description": "Descripción del archivo de instrucciones. Se puede usar para proporcionar contexto adicional o información sobre las instrucciones y se pasa al modelo de lenguaje como parte de la solicitud.",
      "promptHeader.mode.description": "La descripción del archivo de modo. Se puede usar para proporcionar contexto adicional o información sobre el modo al autor.",
      "promptHeader.mode.model": "Modelo que se utilizará en este modo.",
      "promptHeader.mode.tools": "Herramientas que se utilizarán en este modo.",
      "promptHeader.prompt.description": "Descripción del archivo de solicitud. Se puede usar para proporcionar contexto adicional o información sobre la solicitud al autor.",
      "promptHeader.prompt.mode": "El modo que se usará en esta indicación.",
      "promptHeader.prompt.mode.builtInDesc": "Modo de chat integrado",
      "promptHeader.prompt.mode.builtin": "**Modos integrados:**",
      "promptHeader.prompt.mode.custom": "**Modos personalizados:**",
      "promptHeader.prompt.mode.customDesc": "Modo de chat personalizado",
      "promptHeader.prompt.mode.description": "Modo de chat que se va a usar al ejecutar esta indicación.",
      "promptHeader.prompt.model": "Modelo que se utilizará en esta solicitud.",
      "promptHeader.prompt.tools": "Herramientas que se utilizarán en esta solicitud.",
      "toolSetName": "Conjunto de herramientas: {0}\r\n\r\n"
    },
    "vs/workbench/contrib/chat/common/promptSyntax/service/promptsServiceImpl": {
      "prompt.file.detail": "Archivo de indicación: {0}"
    },
    "vs/workbench/contrib/chat/common/promptSyntax/service/promptValidator": {
      "promptValidator.applyToMustBeString": "El atributo “applyTo” debe ser una cadena.",
      "promptValidator.applyToMustBeValidGlob": "El atributo “applyTo” debe ser un patrón global válido.",
      "promptValidator.descriptionMustBeString": "El atributo “description” debe ser una cadena.",
      "promptValidator.descriptionShouldNotBeEmpty": "El atributo “description” no debe estar vacío.",
      "promptValidator.eachToolMustBeString": "Cada nombre de herramienta en el atributo “tools” debe ser una cadena.",
      "promptValidator.excludeModeMustBeArray": "The 'excludeMode' attribute must be an array.",
      "promptValidator.fileNotFound": "No se encontró el archivo “{0}” en “{1}”.",
      "promptValidator.invalidFileReference": "Referencia de archivo no válida “{0}”.",
      "promptValidator.modeMustBeNonEmpty": "El atributo “mode” debe ser una cadena no vacía.",
      "promptValidator.modeMustBeString": "El atributo “mode” debe ser una cadena.",
      "promptValidator.modeNotFound": "Modo desconocido “{0}”. Modos disponibles: {1}.",
      "promptValidator.modelMustBeNonEmpty": "El atributo “model” debe ser una cadena no vacía.",
      "promptValidator.modelMustBeString": "El atributo “model” debe ser una cadena.",
      "promptValidator.modelNotFound": "Modelo “{0}” desconocido.",
      "promptValidator.modelNotSuited": "El modelo “{0}” no es adecuado para el modo de agente.",
      "promptValidator.toolNotFound": "Herramienta desconocida “{0}”.",
      "promptValidator.toolsMustBeArrayOrMap": "El atributo “tools” debe ser una matriz.",
      "promptValidator.toolsOnlyInAgent": "El atributo \"tools\" solo se admite en modo agente. Se ignorará el atributo.",
      "promptValidator.unknownAttribute.instructions": "El atributo \"{0}\" no se admite en archivos de instrucciones. Admitidos: {1}.",
      "promptValidator.unknownAttribute.mode": "El atributo \"{0}\" no se admite en archivos de modo. Admitidos: {1}.",
      "promptValidator.unknownAttribute.prompt": "El atributo \"{0}\" no se admite en archivos de indicación. Admitidos: {1}.",
      "promptValidator.unknownVariableReference": "Herramienta o conjunto de herramientas “{0}” desconocido."
    },
    "vs/workbench/contrib/chat/common/tools/languageModelToolsContribution": {
      "canBeReferencedInPrompt": "Si es true, esta herramienta se muestra como datos adjuntos que el usuario puede agregar manualmente a su solicitud. Los participantes del chat recibirán la herramienta en {0}.",
      "condition": "Condición que debe ser verdadera para que esta herramienta esté habilitada. Tenga en cuenta que una herramienta aún puede ser invocada por otra extensión aunque su condición \"when\" sea false.",
      "descriptions": "Descripción",
      "icon": "Icono que representa esta herramienta. Una ruta de acceso de archivo, un objeto con rutas de acceso de archivo para temas oscuros y claros, o una referencia de icono de tema, como \"\\$(zap)\"",
      "icon.dark": "Ruta de icono cuando se usa un tema oscuro",
      "icon.light": "Ruta del icono cuando se usa un tema ligero",
      "langModelToolSets": "Conjuntos de herramientas de modelo de lenguaje",
      "langModelTools": "Herramientas de modelo de lenguaje",
      "name": "Nombre",
      "parametersSchema": "Esquema JSON para las entradas que acepta esta herramienta. Las entradas deben ser un objeto en el nivel superior. Es posible que un modelo de lenguaje determinado no admita todas las características del esquema JSON. Consulte la documentación de la familia de modelos de lenguaje que usa para obtener más información.",
      "reference": "Nombre de referencia",
      "toolDisplayName": "Nombre legible para esta herramienta que se puede usar para describirla en la interfaz de usuario.",
      "toolModelDescription": "Descripción de esta herramienta que puede usar un modelo de lenguaje para seleccionarla.",
      "toolName": "Un nombre único para esta herramienta. Este nombre debe ser un identificador único global y también se usa como nombre al presentar esta herramienta a un modelo de lenguaje.",
      "toolName2": "Si {0} está habilitado para esta herramienta, el usuario puede usar '#' con este nombre para invocar la herramienta en una consulta. De lo contrario, no se requiere el nombre. El nombre no puede contener espacios en blanco.",
      "toolSetDescription": "Descripción de este conjunto de herramientas.",
      "toolSetIcon": "Icono que representa este conjunto de herramientas, como `$(zap)`",
      "toolSetName": "Un nombre para este conjunto de herramientas. Se usa como referencia y no debe contener espacios en blanco.",
      "toolSetTools": "Lista de herramientas o conjuntos de herramientas que se incluirán en este conjunto de herramientas. No puede estar vacío y debe hacer referencia a las herramientas mediante su `toolReferenceName`.",
      "toolTableDescription": "Descripción",
      "toolTableDisplayName": "Nombre para mostrar",
      "toolTableName": "Nombre",
      "toolTags": "Conjunto de etiquetas que describen aproximadamente las capacidades de la herramienta. Un usuario de herramientas puede usar estas herramientas para filtrar el conjunto de herramientas por solo aquellas que sean relevantes para la tarea que tenga a mano, o puede que quiera seleccionar una etiqueta que se pueda usar para identificar solo las herramientas aportadas por esta extensión.",
      "toolUserDescription": "Descripción de esta herramienta que se puede mostrar al usuario.",
      "tools": "Herramientas",
      "vscode.extension.contributes.toolSets": "Aporta un conjunto de herramientas de modelo de lenguaje que se pueden usar juntas.",
      "vscode.extension.contributes.tools": "Aporta una herramienta que un modelo de lenguaje puede invocar en una sesión de chat o desde un comando independiente. Todas las extensiones pueden usar las herramientas registradas."
    },
    "vs/workbench/contrib/chat/common/tools/manageTodoListTool": {
      "todo.added.multiple": "Se han agregado {0} tareas pendientes",
      "todo.added.single": "Se ha agregado una tarea pendiente",
      "todo.completed": "Completado ({0}/{1}) *{2}*",
      "todo.created.multiple": "Se han creado {0} tareas pendientes",
      "todo.created.single": "Se ha creado 1 tarea pendiente",
      "todo.readOperation": "Leer lista de tareas pendientes",
      "todo.starting": "Iniciando ({0}/{1}) *{2}*",
      "todo.updated": "Lista de tareas pendientes actualizada",
      "todo.updatedList": "Lista de tareas pendientes actualizada",
      "tool.manageTodoList.displayName": "Administrar y realizar un seguimiento de los elementos pendientes para la planificación de tareas",
      "tool.manageTodoList.userDescription": "Herramienta para administrar y hacer seguimiento de elementos pendientes en la planificación de tareas"
    },
    "vs/workbench/contrib/chat/common/voiceChatService": {
      "voiceChatInProgress": "Hay una sesión de conversión de voz en texto en curso para el chat."
    },
    "vs/workbench/contrib/chat/electron-browser/actions/chatDeveloperActions": {
      "workbench.action.chat.openStorageFolder.label": "Abrir la carpeta de almacenamiento del chat"
    },
    "vs/workbench/contrib/chat/electron-browser/actions/voiceChatActions": {
      "keywordActivation.status.active": "Escuchando 'Hey Code'...",
      "keywordActivation.status.inactive": "Esperando a que finalice el chat de voz...",
      "keywordActivation.status.name": "Activación de palabra clave de voz",
      "listening": "Estoy escuchando",
      "scopedChatSynthesisInProgress": "Se define como una ubicación donde la grabación de voz desde el micrófono está en curso para el chat de voz. Esta clave solo se define en el ámbito, por contexto de chat.",
      "scopedVoiceChatGettingReady": "True al prepararse para recibir entradas de voz del micrófono para el chat de voz. Esta clave solo se define en el ámbito, por contexto de chat.",
      "scopedVoiceChatInProgress": "Se define como una ubicación donde la grabación de voz desde el micrófono está en curso para el chat de voz. Esta clave solo se define en el ámbito, por contexto de chat.",
      "voice.keywordActivation": "Controla si se reconoce la frase clave \"Hey Code\" para iniciar una sesión de chat de voz. Al habilitar esta opción, se iniciará la grabación desde el micrófono, pero el audio se procesa localmente y nunca se envía a un servidor.",
      "voice.keywordActivation.chatInContext": "La activación de palabras clave está habilitada y se reconoce \"Hey Code\" para iniciar una sesión de chat de voz en el editor activo o en la vista, según el foco del teclado.",
      "voice.keywordActivation.chatInView": "La activación de palabras clave está habilitada y se reconoce \"Hey Code\" para iniciar una sesión de chat de voz en la vista de chat.",
      "voice.keywordActivation.inlineChat": "La activación por palabra clave está habilitada y a la escucha de \"Hey Code\" para iniciar una sesión de chat de voz en el editor activo, si es posible.",
      "voice.keywordActivation.off": "La activación de palabras clave está deshabilitada.",
      "voice.keywordActivation.quickChat": "La activación de palabras clave está habilitada y se reconoce \"Hey Code\" para iniciar una sesión de chat de voz en el chat rápido.",
      "workbench.action.chat.holdToVoiceChatInChatView.label": "Mantener pulsado para el chat de voz en la vista de chat",
      "workbench.action.chat.inlineVoiceChat": "Chat de voz insertado",
      "workbench.action.chat.quickVoiceChat.label": "Chat de voz rápido",
      "workbench.action.chat.readChatResponseAloud": "Lectura en voz alta",
      "workbench.action.chat.startVoiceChat.label": "Iniciar chat de voz",
      "workbench.action.chat.stopListening.label": "Dejar de escuchar",
      "workbench.action.chat.stopListeningAndSubmit.label": "Dejar de escuchar y enviar",
      "workbench.action.chat.stopReadChatItemAloud": "Detener lectura en voz alta",
      "workbench.action.chat.voiceChatInView.label": "Chat de voz en la vista de chat",
      "workbench.action.speech.stopReadAloud": "Detener lectura en voz alta"
    },
    "vs/workbench/contrib/chat/electron-browser/chat.contribution": {
      "changeWorkspace.detail": "La solicitud de chat se detendrá si cambia el área de trabajo.",
      "changeWorkspace.message": "Hay una solicitud de chat en curso. ¿Está seguro de que desea cambiar el área de trabajo?",
      "chatRequestInProgress": "Hay una solicitud de chat en curso.",
      "closeTheWindow.detail": "La solicitud de chat se detendrá si cierra la ventana.",
      "closeTheWindow.message": "Hay una solicitud de chat en curso. ¿Está seguro de que desea cerrar la ventana?",
      "copilotWorkspaceTrust": "Actualmente, las características de IA solo se admiten en áreas de trabajo de confianza.",
      "exit.detail": "La solicitud de chat se detendrá si sale.",
      "exit.message": "Hay una solicitud de chat en curso. ¿Está seguro de que desea salir?",
      "quit.detail": "La solicitud de chat se detendrá si sale.",
      "quit.message": "Hay una solicitud de chat en curso. ¿Está seguro de que desea salir?",
      "reloadTheWindow.detail": "La solicitud de chat se detendrá si vuelve a cargar la ventana.",
      "reloadTheWindow.message": "Hay una solicitud de chat en curso. ¿Está seguro de que desea volver a cargar la ventana?"
    },
    "vs/workbench/contrib/chat/electron-browser/tools/fetchPageTool": {
      "fetchWebPage.binaryNotSupported": "Los archivos binarios no se admiten en este momento.",
      "fetchWebPage.confirmationMessage.plural": "El contenido web puede contener código malintencionado o intentar ataques de inyección de indicaciones.",
      "fetchWebPage.confirmationTitle.plural": "¿Capturar páginas web?",
      "fetchWebPage.confirmationTitle.singular": "¿Capturar página web?",
      "fetchWebPage.invalidUrl": "Dirección URL no válida",
      "fetchWebPage.invocationMessage.plural": "Capturando {0} recursos",
      "fetchWebPage.invocationMessage.singular": "Capturando {0}",
      "fetchWebPage.invocationMessage.singularAsLink": "Capturando [resource]({0})",
      "fetchWebPage.modelDescription": "Captura el contenido principal de una página web. Esta herramienta es útil para resumir o analizar el contenido de una página web.",
      "fetchWebPage.noValidUrls": "No se proporcionaron direcciones URL válidas.",
      "fetchWebPage.pastTenseMessage.plural": "Se capturaron {0} recursos, pero las siguientes direcciones URL no eran válidas:\r\n\r\n{1}\r\n\r\n",
      "fetchWebPage.pastTenseMessage.singular": "Se ha capturado el recurso, pero la siguiente dirección URL no es válida:\r\n\r\n{0}\r\n\r\n",
      "fetchWebPage.pastTenseMessageResult.plural": "{0} recursos capturados",
      "fetchWebPage.pastTenseMessageResult.singular": "Se capturó {0}",
      "fetchWebPage.pastTenseMessageResult.singularAsLink": "[resource]({0}) capturado",
      "fetchWebPage.urlsDescription": "Matriz de direcciones URL de las que se va a capturar contenido."
    },
    "vs/workbench/contrib/codeActions/browser/codeActionsContribution": {
      "alwaysSave": "Desencadena acciones de código en los guardados explícitos y los guardados automáticos desencadenados por los cambios de foco o ventana.",
      "codeActionsOnSave.generic": "Controla si se deben ejecutar acciones de \"{0}\" en el archivo guardado.",
      "editor.codeActionsOnSave": "Ejecute acciones de código para el editor al guardar. Se deben especificar acciones de código y el editor no debe cerrarse. Cuando {0} se establece en \"afterDelay\", las acciones de código solo se ejecutarán cuando el archivo se guarde explícitamente. Ejemplo: `\"source.organizeImports\": \"explicit\" `",
      "explicit": "Desencadena acciones de código solo cuando se guarda explícitamente.",
      "explicitBoolean": "Desencadena acciones de código solo cuando se guarda explícitamente. Este valor quedará en desuso en favor de \"explicit\".",
      "explicitSave": "Desencadena acciones de código solo cuando se guarda explícitamente",
      "explicitSaveBoolean": "Desencadena acciones de código solo cuando se guarda explícitamente. Este valor quedará en desuso en favor de \"explicit\".",
      "never": "Nunca desencadena acciones de código al guardar.",
      "neverBoolean": "Desencadena acciones de código solo cuando se guarda explícitamente. Este valor quedará en desuso en favor de \"never\".",
      "neverSave": "Nunca desencadena acciones de código al guardar",
      "neverSaveBoolean": "Nunca desencadena acciones de código al guardar. Este valor quedará en desuso en favor de \"never\".",
      "notebook.codeActionsOnSave": "Ejecute una serie de acciones de código para un cuaderno al guardar. Se deben especificar acciones de código y el editor no debe cerrarse. Cuando {0} se establece en \"afterDelay\", las acciones de código solo se ejecutarán cuando el archivo se guarde explícitamente. Ejemplo: `\"notebook.source.organizeImports\": \"explicit\"`"
    },
    "vs/workbench/contrib/codeEditor/browser/accessibility/accessibility": {
      "toggleScreenReaderMode": "Alternar modo de accesibilidad del lector de pantalla",
      "toggleScreenReaderModeDescription": "Alterna un modo optimizado para su uso con lectores de pantalla, dispositivos braille y otras tecnologías de asistencia."
    },
    "vs/workbench/contrib/codeEditor/browser/dictation/editorDictation": {
      "startDictation": "Iniciar dictado en el editor",
      "stopDictation": "Detener dictado en el editor",
      "stopDictationShort1": "Detener dictado ({0})",
      "stopDictationShort2": "Detener dictado",
      "voiceCategory": "Voz"
    },
    "vs/workbench/contrib/codeEditor/browser/diffEditorAccessibilityHelp": {
      "msg1": "Usted está en un editor de diferencias.",
      "msg2": "Vea la diferencia siguiente{0} o anterior{1} en el modo de revisión de diferencias que está optimizado para lectores de pantalla.",
      "msg3": "Ejecute el comando Editor de diferencias: Cambiar lado{0} para alternar entre los editores originales y modificados.",
      "msg4": "Para controlar qué señales de accesibilidad se deben reproducir, se pueden configurar las siguientes opciones: {0}.",
      "msg5": "La configuración accessibility.verbosity.diffEditorActive controla si se realiza un anuncio del editor de diferencias cuando se convierte en el editor activo."
    },
    "vs/workbench/contrib/codeEditor/browser/diffEditorHelper": {
      "hintTimeout": "El algoritmo de comparación se detuvo pronto (después de {0} ms).",
      "hintWhitespace": "Mostrar diferencias de espacios en blanco",
      "removeTimeout": "Quitar límite"
    },
    "vs/workbench/contrib/codeEditor/browser/emptyTextEditorHint/emptyTextEditorHint": {
      "defaultHintAriaLabelWithInlineChat": "Ejecute {0} para formular una pregunta, ejecute {1} para seleccionar un lenguaje para comenzar. Comience a escribir para descartar.",
      "defaultHintAriaLabelWithoutInlineChat": "Ejecute {0} para seleccionar un lenguaje y comenzar. Comience a escribir para descartar.",
      "disableEditorEmptyHint": "Deshabilitar sugerencia de editor vacío",
      "disableHint": " Alternar {0} en la configuración para deshabilitar esta sugerencia.",
      "emptyTextEditorHintWithInlineChat": "[[Generar código]] ({0}) o [[seleccionar un lenguaje]] ({1}). Comience a escribir para descartar o [[no mostrar]] esto de nuevo.",
      "emptyTextEditorHintWithoutInlineChat": "[[Seleccionar un lenguaje]] ({0}) para comenzar. Comience a escribir para descartar o [[no mostrar]] esto de nuevo."
    },
    "vs/workbench/contrib/codeEditor/browser/find/simpleFindWidget": {
      "ariaSearchNoInput": "Escribir entrada de búsqueda",
      "ariaSearchNoResult": "{0} encontrado para '{1}'",
      "ariaSearchNoResultEmpty": "{0} encontrado",
      "ariaSearchNoResultWithLineNumNoCurrentMatch": "{0} encontrado para '{1}'",
      "label.closeButton": "Cerrar",
      "label.find": "Buscar",
      "label.nextMatchButton": "Coincidencia siguiente",
      "label.previousMatchButton": "Coincidencia anterior",
      "placeholder.find": "Buscar",
      "simpleFindWidget.sashBorder": "Color de borde del borde de la banda."
    },
    "vs/workbench/contrib/codeEditor/browser/inspectEditorTokens/inspectEditorTokens": {
      "inspectEditorTokens": "Desarrollador: Inspeccionar los tokens y ámbitos del editor",
      "inspectTMScopesWidget.loading": "Cargando..."
    },
    "vs/workbench/contrib/codeEditor/browser/inspectKeybindings": {
      "workbench.action.inspectKeyMap": "Inspeccionar las asignaciones de clave",
      "workbench.action.inspectKeyMapJSON": "Inspeccionar asignaciones de claves (JSON)"
    },
    "vs/workbench/contrib/codeEditor/browser/largeFileOptimizations": {
      "largeFile": "{0}: la tokenización, el ajuste, el plegado, el CodeLens, el resaltado de palabras y el desplazamiento permanente se han desactivado para este archivo grande con el fin de reducir el uso de memoria y evitar la inmovilización o bloqueo.",
      "removeOptimizations": "Forzar la activación de características",
      "reopenFilePrompt": "Vuelva a abrir el archivo para que esta configuración surta efecto."
    },
    "vs/workbench/contrib/codeEditor/browser/outline/documentSymbolsOutline": {
      "document": "Símbolos del documento"
    },
    "vs/workbench/contrib/codeEditor/browser/outline/documentSymbolsTree": {
      "1.problem": "1 problema en este elemento",
      "N.problem": "{0} problemas en este elemento",
      "deep.problem": "Contiene elementos con problemas",
      "title.template": "{0} ({1})"
    },
    "vs/workbench/contrib/codeEditor/browser/quickaccess/gotoLineQuickAccess": {
      "gotoLine": "Vaya a Línea/Columna...",
      "gotoLineQuickAccess": "Ir a Línea/Columna",
      "gotoLineQuickAccessPlaceholder": "Escriba el número de línea y la columna opcional a la que ir (por ejemplo, 42:5 para la línea 42 y la columna 5)."
    },
    "vs/workbench/contrib/codeEditor/browser/quickaccess/gotoSymbolQuickAccess": {
      "empty": "No hay ninguna entrada coincidente.",
      "gotoSymbol": "Ir al símbolo en el editor...",
      "gotoSymbolByCategoryQuickAccess": "Ir a símbolo en el editor por categoría",
      "gotoSymbolQuickAccess": "Ir a símbolo en el editor",
      "gotoSymbolQuickAccessPlaceholder": "Escriba el nombre de un símbolo al que ir.",
      "miGotoSymbolInEditor": "Ir al &&símbolo en el editor..."
    },
    "vs/workbench/contrib/codeEditor/browser/saveParticipants": {
      "codeAction.apply": "Aplicando la acción de código \"{0}\".",
      "codeaction": "Correcciones rápidas",
      "codeaction.get2": "Obteniendo acciones de código de {0} ([configure]({1})).",
      "formatting2": "Se está ejecutando el formateador \"{0}\" ([configure]({1}))."
    },
    "vs/workbench/contrib/codeEditor/browser/toggleColumnSelection": {
      "miColumnSelection": "Modo de &&selección de columna",
      "toggleColumnSelection": "Alternar el modo de selección de columnas"
    },
    "vs/workbench/contrib/codeEditor/browser/toggleMinimap": {
      "miMinimap": "&&Minimapa",
      "toggleMinimap": "Alternar minimapa"
    },
    "vs/workbench/contrib/codeEditor/browser/toggleMultiCursorModifier": {
      "miMultiCursorAlt": "Cambiar a Alt+Clic para cursor múltiple",
      "miMultiCursorCmd": "Cambiar a Cmd+Clic para cursor múltiple",
      "miMultiCursorCtrl": "Cambiar a Ctrl+Clic para cursor múltiple",
      "toggleLocation": "Alternar modificador multicursor"
    },
    "vs/workbench/contrib/codeEditor/browser/toggleOvertype": {
      "mitoggleOvertypeInsertMode": "&&Alternar el modo de sobrescritura o inserción",
      "toggleOvertypeInsertMode": "Alternar el modo de sobrescritura o inserción",
      "toggleOvertypeMode.description": "Alternar entre el modo de sobrescritura e inserción"
    },
    "vs/workbench/contrib/codeEditor/browser/toggleRenderControlCharacter": {
      "miToggleRenderControlCharacters": "Representar &&caracteres de control",
      "toggleRenderControlCharacters": "Alternar caracteres de control"
    },
    "vs/workbench/contrib/codeEditor/browser/toggleRenderWhitespace": {
      "miToggleRenderWhitespace": "&&Representar espacio en blanco",
      "toggleRenderWhitespace": "Alternar representación de espacio en blanco"
    },
    "vs/workbench/contrib/codeEditor/browser/toggleWordWrap": {
      "editorWordWrap": "Indica si el editor está usando el ajuste automático de línea.",
      "miToggleWordWrap": "&&Ajuste de palabra",
      "toggle.wordwrap": "Ver: Alternar ajuste de línea",
      "unwrapMinified": "Deshabilitar ajuste para este archivo",
      "wrapMinified": "Habilitar ajuste para este archivo"
    },
    "vs/workbench/contrib/codeEditor/common/languageConfigurationExtensionPoint": {
      "formatError": "{0}: formato no válido, se esperaba un objeto JSON.",
      "parseErrors": "Errores al analizar {0}: {1}",
      "schema.autoCloseBefore": "Define qué caracteres deben aparecer después del cursor para que se aplique el cierre automático de corchetes o comillas al usar la configuración de autocierre \"languageDefined\". Suele ser el juego de caracteres que no pueden iniciar una expresión.",
      "schema.autoClosingPairs": "Define el par de corchetes. Cuando se escribe un corchete de apertura, se inserta automáticamente el corchete de cierre.",
      "schema.autoClosingPairs.notIn": "Define una lista de ámbitos donde los pares automáticos están deshabilitados.",
      "schema.blockComment.begin": "Secuencia de caracteres que inicia un comentario de bloque.",
      "schema.blockComment.end": "Secuencia de caracteres que finaliza un comentario de bloque.",
      "schema.blockComments": "Define cómo se marcan los comentarios de bloque.",
      "schema.brackets": "Define los símbolos de corchetes que aumentan o disminuyen la sangría. Cuando la coloración de pares de corchetes está activada y {0} no está definida, también define los pares de corchetes que se colorean según su nivel de anidamiento.",
      "schema.closeBracket": "Secuencia de cadena o corchete de cierre.",
      "schema.colorizedBracketPairs": "Define los pares de corchetes que se colorean según su nivel de anidamiento si la coloración de pares de corchetes está activada. Cualquier paréntesis incluido aquí que no esté incluido en {0} se incluirá automáticamente en {0}.",
      "schema.comments": "Define los símbolos de comentario",
      "schema.folding": "Configuración del plegamiento de idioma.",
      "schema.folding.markers": "Marcadores de plegado específicos de un idioma, como \"'#region\" o \"#endregion\". Se probarán los valores regex en relación con el contenido de todas las líneas, y deben estar diseñados de manera eficiente.",
      "schema.folding.markers.end": "El patrón de expresión regular para el marcador de fin. La expresión regular debe comenzar con '^'.",
      "schema.folding.markers.start": "El patrón de expresión regular para el marcador de inicio. La expresión regular debe comenzar con '^'.",
      "schema.folding.offSide": "Un idioma se adhiere a la regla del fuera de juego si los bloques en ese idioma se expresan por su sangría. Si se establece, las líneas vacías pertenecen al bloque posterior.",
      "schema.indentationRules": "Configuración de sangría del idioma.",
      "schema.indentationRules.decreaseIndentPattern": "Si una línea coincide con este patrón, se debe quitar sangría una vez en todas las líneas que le siguen (hasta que se cumpla otra regla).",
      "schema.indentationRules.decreaseIndentPattern.errorMessage": "Debe coincidir con el patrón `/^([gimuy]+)$/`.",
      "schema.indentationRules.decreaseIndentPattern.flags": "Las marcas de RegExp para decreaseIndentPattern.",
      "schema.indentationRules.decreaseIndentPattern.pattern": "El patrón de RegExp para decreaseIndentPattern.",
      "schema.indentationRules.increaseIndentPattern": "Si una línea coincide con este patrón, todas las líneas después de ella deben sangrarse una vez (hasta que otra regla coincida). ",
      "schema.indentationRules.increaseIndentPattern.errorMessage": "Debe coincidir con el patrón `/^([gimuy]+)$/`.",
      "schema.indentationRules.increaseIndentPattern.flags": "Las marcas de RegExp para increaseIndentPattern.",
      "schema.indentationRules.increaseIndentPattern.pattern": "El patrón de RegExp para increaseIndentPattern.",
      "schema.indentationRules.indentNextLinePattern": "Si una línea coincide con este patrón **solo la línea siguiente** después de ella se debe sangrar una vez.",
      "schema.indentationRules.indentNextLinePattern.errorMessage": "Debe coincidir con el patrón `/^([gimuy]+)$/`.",
      "schema.indentationRules.indentNextLinePattern.flags": "Las marcas de RegExp para indentNextLinePattern.",
      "schema.indentationRules.indentNextLinePattern.pattern": "El patrón de RegExp para indentNextLinePattern.",
      "schema.indentationRules.unIndentedLinePattern": "Si una línea coincide con este patrón, su sangría no se debe cambiar y no se debe evaluar utilizando las otras reglas.",
      "schema.indentationRules.unIndentedLinePattern.errorMessage": "Debe coincidir con el patrón `/^([gimuy]+)$/`.",
      "schema.indentationRules.unIndentedLinePattern.flags": "Las marcas de RegExp para unIndentedLinePattern.",
      "schema.indentationRules.unIndentedLinePattern.pattern": "El patrón de RegExp para unIndentedLinePattern.",
      "schema.lineComment.comment": "Secuencia de caracteres que inicia un comentario de línea.",
      "schema.lineComment.noIndent": "Indica si no se debe aplicar sangría al token de comentario y colocarlo en la primera columna. El valor predeterminado es falso.",
      "schema.lineComment.object": "Configuración de comentarios de línea.",
      "schema.onEnterRules": "Reglas del lenguaje que se van a evaluar al presionar Entrar.",
      "schema.onEnterRules.action": "Acción que se va a ejecutar.",
      "schema.onEnterRules.action.appendText": "Describe el texto que se va a anexar después de la línea nueva y después de la sangría.",
      "schema.onEnterRules.action.indent": "Describir qué debe hacerse con la sangría",
      "schema.onEnterRules.action.indent.indent": "Inserte una línea nueva y aplique sangría una vez (en relación con la sangría de la línea anterior).",
      "schema.onEnterRules.action.indent.indentOutdent": "Inserte dos líneas nuevas:\r\n - La primera con sangría que mantendrá el cursor\r\n - La segunda en el mismo nivel de sangría",
      "schema.onEnterRules.action.indent.none": "Inserte una línea nueva y copie la sangría de la línea anterior.",
      "schema.onEnterRules.action.indent.outdent": "Inserte una línea nueva y anule la sangría una vez (en relación con la sangría de la línea anterior).",
      "schema.onEnterRules.action.removeText": "Describe el número de caracteres que se van a quitar de la sangría de la línea nueva.",
      "schema.onEnterRules.afterText": "Esta regla solo se ejecutará si el texto situado después del cursor coincide con esta expresión regular.",
      "schema.onEnterRules.afterText.errorMessage": "Debe coincidir con el patrón `/^([gimuy]+)$/`.",
      "schema.onEnterRules.afterText.flags": "Las marcas de RegExp para afterText.",
      "schema.onEnterRules.afterText.pattern": "El patrón de RegExp para afterText.",
      "schema.onEnterRules.beforeText": "Esta regla solo se ejecutará si el texto situado antes del cursor coincide con esta expresión regular.",
      "schema.onEnterRules.beforeText.errorMessage": "Debe coincidir con el patrón `/^([gimuy]+)$/`.",
      "schema.onEnterRules.beforeText.flags": "Las marcas de RegExp para beforeText.",
      "schema.onEnterRules.beforeText.pattern": "El patrón de RegExp para beforeText.",
      "schema.onEnterRules.previousLineText": "Esta regla solo se ejecutará si el texto que hay por encima de la línea coincide con esta expresión regular.",
      "schema.onEnterRules.previousLineText.errorMessage": "Debe coincidir con el patrón `/^([gimuy]+)$/`.",
      "schema.onEnterRules.previousLineText.flags": "Las marcas de RegExp para previousLineText.",
      "schema.onEnterRules.previousLineText.pattern": "El patrón de RegExp para previousLineText.",
      "schema.openBracket": "Secuencia de cadena o corchete de apertura.",
      "schema.surroundingPairs": "Define los pares de corchetes que se pueden usar para encerrar una cadena seleccionada.",
      "schema.wordPattern": "Define qué se considera como una palabra en el lenguaje de programación.",
      "schema.wordPattern.flags": "Los flags de expresión regular utilizados para localizar palabras.",
      "schema.wordPattern.flags.errorMessage": "Debe coincidir con el patrón `/^([gimuy]+)$/`.",
      "schema.wordPattern.pattern": "El patrón de expresión regular utilizado para localizar palabras."
    },
    "vs/workbench/contrib/codeEditor/electron-browser/selectionClipboard": {
      "actions.pasteSelectionClipboard": "Pegar Portapapeles de selección"
    },
    "vs/workbench/contrib/codeEditor/electron-browser/startDebugTextMate": {
      "startDebugTextMate": "Iniciar el registro de gramática de sintaxis de TextMate"
    },
    "vs/workbench/contrib/commands/common/commands.contribution": {
      "runCommands": "Ejecutar comandos",
      "runCommands.commands": "Comandos para ejecutar",
      "runCommands.description": "Ejecutar varios comandos",
      "runCommands.invalidArgs": "'runCommands' ha recibido un argumento con un tipo incorrecto. Revise el argumento pasado al comando.",
      "runCommands.noCommandsToRun": "'runCommands' no ha recibido comandos para ejecutar. ¿Ha olvidado pasar comandos en el argumento 'runCommands'?"
    },
    "vs/workbench/contrib/comments/browser/commentColors": {
      "commentReplyInputBackground": "Color de fondo del cuadro de entrada de respuesta del comentario.",
      "commentThreadActiveRangeBackground": "Color de fondo para el rango de comentarios seleccionado o al mantener el puntero.",
      "commentThreadRangeBackground": "Color de fondo para intervalos de comentarios.",
      "resolvedCommentBorder": "Color de bordes y flecha para los comentarios resueltos.",
      "resolvedCommentIcon": "Color del icono para los comentarios resueltos.",
      "unresolvedCommentBorder": "Color de bordes y flecha para los comentarios sin resolver.",
      "unresolvedCommentIcon": "Color del icono para los comentarios sin resolver."
    },
    "vs/workbench/contrib/comments/browser/commentGlyphWidget": {
      "editorGutterCommentGlyphForeground": "Color de decoración del margen del editor para comentar glifos.",
      "editorGutterCommentRangeForeground": "Color de decoración del medianil del editor para los intervalos de comentarios. Este color debe ser opaco.",
      "editorGutterCommentUnresolvedGlyphForeground": "Color de decoración del medianil del editor para glifos de comentarios para hilos de comentarios sin resolver.",
      "editorOverviewRuler.commentForeground": "Color de decoración de regla de información general del editor para los comentarios resueltos. Este color debe ser opaco.",
      "editorOverviewRuler.commentUnresolvedForeground": "Color de decoración de regla de información general del editor para los comentarios sin resolver. Este color debe ser opaco."
    },
    "vs/workbench/contrib/comments/browser/commentNode": {
      "commentAddReactionDefaultError": "Error al eliminar la reacción del comentario",
      "commentAddReactionError": "Error al eliminar la reacción del comentario: {0}.",
      "commentDeleteReactionDefaultError": "Error al eliminar la reacción del comentario",
      "commentDeleteReactionError": "Error al eliminar la reacción del comentario: {0}.",
      "commentToggleReaction": "Alternar reacción",
      "commentToggleReactionDefaultError": "Error al alternar la reacción del comentario",
      "commentToggleReactionError": "Error al alternar la reacción del comentario: {0}."
    },
    "vs/workbench/contrib/comments/browser/commentReply": {
      "newComment": "Escriba un nuevo comentario",
      "reply": "Responder..."
    },
    "vs/workbench/contrib/comments/browser/comments.contribution": {
      "collapseAll": "Contraer todo",
      "collapseOnResolve": "Controla si el hilo de comentarios debe contraerse cuando se resuelve.",
      "comments.maxHeight": "Controla si el widget de comentarios se desplaza o se expande.",
      "comments.openPanel.deprecated": "Esta configuración está en desuso en favor de `comments.openView`.",
      "comments.openView": "Controla cuándo debe abrirse la vista de comentarios.",
      "comments.openView.file": "La vista de comentarios se abrirá cuando un archivo con comentarios esté activo.",
      "comments.openView.firstFile": "Si la vista de comentarios aún no se ha abierto durante esta sesión, se abrirá por primera vez durante una sesión en la que un archivo con comentarios está activo.",
      "comments.openView.firstFileUnresolved": "Si la vista de comentarios aún no se ha abierto durante esta sesión y el comentario no está resuelto, se abrirá por primera vez durante una sesión en la que un archivo con comentarios esté activo.",
      "comments.openView.never": "La vista de comentarios nunca se abrirá.",
      "comments.visible": "Controla la visibilidad de la barra de comentarios y los hilos de comentarios en los editores que tienen rangos de comentarios y comentarios. Los comentarios siguen siendo accesibles a través de la vista Comentarios y harán que los comentarios se activen de la misma manera que se ejecuta el comando \"Comentarios: Alternar comentarios del editor\" para alternar los comentarios.",
      "commentsConfigurationTitle": "Comentarios",
      "confirmOnCollapse": "Controla si se muestra un cuadro de diálogo de confirmación al contraer un hilo de comentarios.",
      "confirmOnCollapse.never": "No mostrar nunca un cuadro de diálogo de confirmación al contraer un hilo de comentarios.",
      "confirmOnCollapse.whenHasUnsubmittedComments": "Muestra un cuadro de diálogo de confirmación al contraer un hilo de comentarios con comentarios no enviados.",
      "expandAll": "Expandir todo",
      "openComments": "Controles cuándo se debe abrir el panel de comentarios.",
      "reply": "Responder",
      "totalUnresolvedComments": "{0} Comentarios sin resolver",
      "useRelativeTime": "Determina si se usará la hora relativa en las marcas de tiempo de comentarios (por ejemplo, \"hace 1 día\")."
    },
    "vs/workbench/contrib/comments/browser/commentsAccessibility": {
      "addCommentNoKb": "- Agregar comentario en la selección actual{0}.",
      "commentCommands": "Algunos comandos de comentario útiles incluyen:",
      "escape": "- Descartar comentario (Escape)",
      "intro": "El editor contiene rangos que admiten comentarios. Algunos comandos útiles incluyen:",
      "introWidget": "Este widget contiene un área de introducción de texto para la composición de nuevos comentarios y acciones a las que se pueden agregar pestañas una vez habilitado el modo de enfoque de movimiento de pestañas con el comando Alternar tecla de tabulación para mover el foco{0}.",
      "next": "- Ir al siguiente intervalo de comentarios{0}.",
      "nextCommentThreadKb": "- Ir al siguiente subproceso de comentario{0}.",
      "nextCommentedRangeKb": "- Ir al siguiente intervalo comentado{0}.",
      "previous": "- Ir al intervalo de comentarios anterior{0}.",
      "previousCommentThreadKb": "- Ir al subproceso de comentario anterior{0}.",
      "previousCommentedRangeKb": "- Ir al rango comentado anterior{0}.",
      "submitComment": "- Enviar comentario{0}."
    },
    "vs/workbench/contrib/comments/browser/commentsController": {
      "commentRange": "Línea {0}",
      "commentRangeStart": "Líneas {0} a {1}",
      "comments.addCommand.error": "El cursor debe estar dentro de un rango de comentarios para agregar un comentario.",
      "comments.addFileCommentCommand.error": "No se permiten comentarios de archivo en este archivo.",
      "hasCommentRanges": "El editor tiene rangos de comentarios.",
      "hasCommentRangesKb": "El editor tiene rangos de comentarios. Ejecute el comando Abrir ayuda de accesibilidad ({0}), para obtener más información.",
      "hasCommentRangesNoKb": "El editor tiene intervalos de comentarios. Ejecute el comando Abrir ayuda de accesibilidad, que actualmente no se puede desencadenar mediante un enlace de teclado, para obtener más información.",
      "pickCommentService": "Seleccione Proveedor de Comentario"
    },
    "vs/workbench/contrib/comments/browser/commentsEditorContribution": {
      "comments.NextCommentedRange": "Ir al siguiente rango comentado",
      "comments.addCommand": "Agregar comentario en la selección actual",
      "comments.collapseAll": "Contraer todos los comentarios",
      "comments.expandAll": "Expandir todos los comentarios",
      "comments.expandUnresolved": "Expandir comentarios sin resolver",
      "comments.focusCommand.error": "El cursor debe estar en una línea con un comentario para enfocar el comentario",
      "comments.focusCommentOnCurrentLine": "Comentario de foco en la línea actual",
      "comments.nextCommentingRange": "Ir al rango de comentarios siguiente",
      "comments.previousCommentedRange": "Ir al rango comentado anterior",
      "comments.previousCommentingRange": "Ir al rango de comentarios anterior",
      "comments.toggleCommenting": "Alternar comentarios del editor",
      "commentsCategory": "Comentarios"
    },
    "vs/workbench/contrib/comments/browser/commentsModel": {
      "noComments": "Aún no hay ningún comentario en esta área de trabajo."
    },
    "vs/workbench/contrib/comments/browser/commentsTreeViewer": {
      "commentCount": "1 comentario",
      "commentLine": "[Lín. {0}]",
      "commentRange": "[Lín. {0}-{1}]",
      "comments.view.title": "Comentarios",
      "commentsCountReplies": "{0} respuestas",
      "commentsCountReply": "1 respuesta",
      "image": "Imagen",
      "imageWithLabel": "Imagen: {0}",
      "lastReplyFrom": "Última respuesta de {0}",
      "outdated": "Obsoleto"
    },
    "vs/workbench/contrib/comments/browser/commentsView": {
      "accessibleViewHint": "\r\nInspeccione esto en la vista accesible ({0}).",
      "acessibleViewHintNoKbOpen": "\r\nInspeccione esto en la vista accesible mediante el comando Abrir vista accesible, que actualmente no se puede desencadenar mediante el enlace de teclado.",
      "comments.filter.ariaLabel": "Filtrar comentarios",
      "comments.filter.placeholder": "Filtro (por ejemplo, texto, autor)",
      "fileCommentLabel": "en {0}",
      "multiLineCommentLabel": "de la línea {0} a la línea {1} en {2}",
      "oneLineCommentLabel": "en la línea {0} columna {1} en {2}",
      "replyCount": " {0} respuestas,",
      "resourceWithCommentLabel": "{0}: {1}\r\n{2}\r\n{3}\r\n{4}",
      "resourceWithCommentLabelOutdated": "Obsoleto de {0}: {1}\r\n{2}\r\n{3}\r\n{4}",
      "resourceWithCommentThreadsLabel": "Comentarios en {0}, ruta de acceso completa {1}",
      "resourceWithRepliesLabel": "{0} {1}",
      "rootCommentsLabel": "Comentarios para el área de trabajo actual",
      "showing filtered results": "Se muestran {0} de {1}"
    },
    "vs/workbench/contrib/comments/browser/commentsViewActions": {
      "comment sorts": "Ordenar por",
      "comments": "Comentarios",
      "commentsClearFilterText": "Borrar texto de filtro",
      "focusCommentsFilter": "Filtro Enfocar comentarios",
      "focusCommentsList": "Vista Enfocar comentarios",
      "resolved": "Mostrar resueltos",
      "sorting by position in file": "Posición en el campo",
      "sorting by updated at": "Hora de actualización",
      "toggle resolved": "Mostrar resueltos",
      "toggle sorting by resource": "Posición en el campo",
      "toggle sorting by updated at": "Hora de actualización",
      "toggle unresolved": "Mostrar sin resolver",
      "unresolved": "Mostrar sin resolver"
    },
    "vs/workbench/contrib/comments/browser/commentThreadBody": {
      "commentThreadAria": "Hilo de comentarios con {0} comentarios. {1}.",
      "commentThreadAria.document": "Hilo de comentarios con {0} comentarios en todo el documento. {1}.",
      "commentThreadAria.withRange": "Hilo de comentarios con comentarios {0} en las líneas {1} a través de {2}. {3}."
    },
    "vs/workbench/contrib/comments/browser/commentThreadHeader": {
      "collapseIcon": "Icono para contraer un comentario de revisión.",
      "label.collapse": "Contraer",
      "startThread": "Iniciar discusión"
    },
    "vs/workbench/contrib/comments/browser/commentThreadWidget": {
      "commentLabel": "Comentario",
      "commentLabelWithKeybinding": "{0}, use ({1}) para la ayuda de accesibilidad del editor",
      "commentLabelWithKeybindingNoKeybinding": "{0}, ejecute el comando Abrir ayuda de accesibilidad, que actualmente no se puede desencadenar mediante un enlace de teclado."
    },
    "vs/workbench/contrib/comments/browser/commentThreadZoneWidget": {
      "confirmCollapse": "Al contraer este hilo de comentarios, se descartarán los comentarios no enviados. ¿Está seguro de que desea descartar estos comentarios?",
      "discard": "Descartar",
      "neverAskAgain": "No volver a preguntarme"
    },
    "vs/workbench/contrib/comments/browser/reactionsAction": {
      "comment.reactionLabelMany": "{0}{1} reacciones con {2}",
      "comment.reactionLabelNone": "{0}{1} reacción",
      "comment.reactionLabelOne": "{0}1 reacción con {1}",
      "comment.reactionLessThanTen": "{0}{1} reaccionó con {2}",
      "comment.reactionMoreThanTen": "{0}{1} y {2} más reaccionaron con {3}",
      "comment.toggleableReaction": "Alternar reacción, ",
      "pickReactions": "Recoger las reacciones..."
    },
    "vs/workbench/contrib/comments/common/commentContextKeys": {
      "comment": "Valor de contexto del comentario",
      "commentController": "Id. del controlador de comentarios asociado a un hilo de comentarios",
      "commentFocused": "Establecer cuándo se pone en foco el comentario",
      "commentIsEmpty": "Se establece cuando el comentario no tiene ninguna entrada",
      "commentThread": "Valor de contexto del hilo de comentarios",
      "commentThreadIsEmpty": "Se establece cuando el hilo de comentarios no tiene comentarios",
      "commentingEnabled": "Si la funcionalidad de comentarios está habilitada",
      "editorHasCommentingRange": "Si el editor activo tiene un rango de comentarios",
      "hasComment": "Si la posición en el cursor activo tiene un comentario",
      "hasCommentingProvider": "Si el área de trabajo abierta tiene comentarios o intervalos de comentarios.",
      "hasCommentingRange": "Si la posición en el cursor activo tiene un intervalo de comentarios"
    },
    "vs/workbench/contrib/customEditor/browser/customEditorInput": {
      "editorCannotMove": "No se puede mover ''{0}: el editor contiene cambios que solo se pueden guardar en su ventana actual.",
      "editorUnsupportedInWindow": "No se puede abrir el editor en esta ventana, contiene modificaciones que solo se pueden guardar en la ventana original.",
      "reopenInOriginalWindow": "Abrir en la ventana original"
    },
    "vs/workbench/contrib/customEditor/common/contributedCustomEditors": {
      "builtinProviderDisplayName": "Integrado"
    },
    "vs/workbench/contrib/customEditor/common/customEditor": {
      "context.customEditor": "El valor viewType del editor personalizado activo."
    },
    "vs/workbench/contrib/customEditor/common/customTextEditorModel": {
      "vetoExtHostRestart": "Aún hay abierto un editor de texto proporcionado por la extensión para '{0}' que, de lo contrario, se cerraría."
    },
    "vs/workbench/contrib/customEditor/common/extensionPoint": {
      "contributes.customEditors": "Editores personalizados aportados.",
      "contributes.displayName": "Nombre en lenguaje natural del editor personalizado. Se muestra a los usuarios cuando se selecciona el editor que se va a usar.",
      "contributes.priority": "Controla si el editor personalizado se habilita automáticamente cuando el usuario abre un archivo. Los usuarios pueden invalidar esto con el valor \"workbench.editorAssociations\".",
      "contributes.priority.default": "El editor se usa automáticamente cuando el usuario abre un recurso, siempre que no se hayan registrado otros editores personalizados predeterminados para dicho recurso.",
      "contributes.priority.option": "El editor no se usa automáticamente cuando el usuario abre un recurso, pero un usuario puede cambiar al editor mediante el comando \"Reopen With\".",
      "contributes.selector": "Conjunto de patrones globales para los que está habilitado el editor personalizado.",
      "contributes.selector.filenamePattern": "Patrones globales para los que está habilitado el editor personalizado.",
      "contributes.viewType": "Identificador para el editor personalizado. Debe ser único en todos los editores personalizados, por lo que se recomienda incluir el id. de extensión como parte de \"viewType\". \"viewType\" se utiliza al registrar editores personalizados con \"vscode. registerCustomEditorProvider\" y en \"onCustomEditor:${id}\" [evento de activación](https://code.visualstudio.com/api/references/activation-events).",
      "customEditors": "Editores personalizados",
      "customEditors filenamePattern": "Patrón de nombre de archivo",
      "customEditors priority": "Prioridad",
      "customEditors view type": "Tipo de vista"
    },
    "vs/workbench/contrib/debug/browser/baseDebugView": {
      "debug.lazyButton.tooltip": "Haga clic para expandir"
    },
    "vs/workbench/contrib/debug/browser/breakpointEditorContribution": {
      "addBreakpoint": "Agregar punto de interrupción",
      "addConditionalBreakpoint": "Agregar punto de interrupción condicional...",
      "addLogPoint": "Agregar punto de registro",
      "addTriggeredBreakpoint": "Agregar punto de interrupción desencadenado...",
      "breakpoint": "Punto de interrupción",
      "breakpointHasConditionDisabled": "Este {0} tiene {1} que se perderá al quitarse. Considere habilitar {0} en su lugar.",
      "breakpointHasConditionEnabled": "Este {0} tiene una {1} que se perderá al quitarla. Considere la posibilidad de desactivar el {0} en su lugar.",
      "breakpointHelper": "Haga clic para agregar un punto de interrupción",
      "condition": "Condición",
      "debugIcon.breakpointCurrentStackframeForeground": "Color de icono del marco de pila del punto de interrupción actual.",
      "debugIcon.breakpointDisabledForeground": "Color de icono para puntos de interrupción deshabilitados.",
      "debugIcon.breakpointForeground": "Color de icono de los puntos de interrupción.",
      "debugIcon.breakpointStackframeForeground": "Color de icono de los marcos de pila de todos los puntos de interrupción.",
      "debugIcon.breakpointUnverifiedForeground": "Color de icono de los puntos de interrupción sin verificar.",
      "disable": "&&Deshabilitar",
      "disableBreakpoint": "Deshabilitar {0}",
      "disableBreakpointOnLine": "Deshabilitar punto de interrupción de línea",
      "disableInlineColumnBreakpoint": "Deshabilitar el punto de interrupción insertado en la columna {0}",
      "disableLogPoint": "{0} {1}",
      "editBreakpoint": "Editar {0}...",
      "editBreakpoints": "Editar puntos de interrupción",
      "editInlineBreakpointOnColumn": "Editar el punto de interrupción insertado en la columna {0}",
      "editLineBreakpoint": "Editar punto de interrupción de línea",
      "enable": "&&Habilitar",
      "enableBreakpoint": "Activar {0}",
      "enableBreakpointOnLine": "Habilitar punto de interrupción de línea",
      "enableBreakpoints": "Habilitar el punto de interrupción insertado en la columna {0}",
      "enableDisableBreakpoints": "Habilitar o deshabilitar puntos de interrupción",
      "logPoint": "Punto de registro",
      "message": "Mensaje",
      "removeBreakpoint": "Quitar {0}",
      "removeBreakpoints": "Quitar puntos de interrupción",
      "removeInlineBreakpointOnColumn": "Quitar el punto de interrupción insertado en la columna {0}",
      "removeLineBreakpoint": "Quitar punto de interrupción de línea",
      "removeLogPoint": "&&Quitar {0}",
      "runToLine": "Ir a la línea"
    },
    "vs/workbench/contrib/debug/browser/breakpointsView": {
      "access": "Acceso",
      "activateBreakpoints": "Alternar Activar puntos de interrupción",
      "addDataBreakpointOnAddress": "Agregar punto de interrupción de datos en la dirección",
      "addFunctionBreakpoint": "Agregar punto de interrupción de función",
      "breakpoint": "Punto de interrupción",
      "breakpointUnsupported": "Los puntos de interrupción de este tipo no son compatibles con el depurador",
      "breakpoints": "Puntos de interrupción",
      "dataBreakPointExpresionAriaLabel": "Expresión de tipo. El punto de interrupción de datos se interrumpirá cuando la expresión se evalúe como true",
      "dataBreakPointHitCountAriaLabel": "Escriba el número de llamadas. El punto de interrupción de datos se interrumpirá cuando se alcance el número de llamadas.",
      "dataBreakpoint": "Punto de interrupción de datos",
      "dataBreakpointAccessType": "Seleccionar el tipo de acceso que se va a supervisar",
      "dataBreakpointAddrFormat": "La dirección debe estar formada por un rango de números de la forma \"[Inicio] - [Fin]\" o \"[Inicio] + [Bytes]\".",
      "dataBreakpointAddrStartEnd": "El número debe ser un entero decimal o un valor hexadecimal que empiece por \"0x\", obtenido {0}",
      "dataBreakpointError": "No se pudo establecer el punto de interrupción de datos en {0}: {1}",
      "dataBreakpointExpressionPlaceholder": "Interrumpir cuando la expresión se evalúe como true",
      "dataBreakpointHitCountPlaceholder": "Interrumpir cuando se alcance el número de llamadas",
      "dataBreakpointMemoryRangePlaceholder": "Intervalo absoluto (0x1234 - 0x1300) o intervalo de bytes después de una dirección (0x1234 + 0xff)",
      "dataBreakpointMemoryRangePrompt": "Escriba un intervalo de memoria en el que se va a interrumpir",
      "dataBreakpointUnsupported": "Puntos de interrupción de datos no admitidos por este tipo de depuración",
      "dataBreakpointsNotSupported": "Los puntos de interrupción de datos no son compatibles con este tipo de depuración",
      "debug.decimal.address": "Dirección decimal: {0}",
      "disableAllBreakpoints": "Deshabilitar todos los puntos de interrupción",
      "disabledBreakpoint": "Punto de interrupción deshabilitado",
      "disabledLogpoint": "Punto de registro deshabilitado",
      "editBreakpoint": "Editar condición de función...",
      "editCondition": "Editar condición...",
      "editDataBreakpointOnAddress": "Editar dirección...",
      "editHitCount": "Editar el número de llamadas...",
      "editMode": "Modo de edición...",
      "enableAllBreakpoints": "Habilitar todos los puntos de interrupción",
      "exceptionBreakpointAriaLabel": "Condición del punto de interrupción de excepción de tipo",
      "exceptionBreakpointPlaceholder": "Interrumpir cuando la expresión se evalúe como true",
      "expression": "Condición: {0}",
      "expressionAndHitCount": "Condición: {0} | Número de llamadas: {1}",
      "expressionCondition": "Condición de expresión: {0}",
      "functionBreakPointExpresionAriaLabel": "Expresión de tipo. El punto de interrupción de función se interrumpirá cuando la expresión se evalúe como true.",
      "functionBreakPointHitCountAriaLabel": "Escriba el número de llamadas. El punto de interrupción de función se interrumpirá cuando se alcance el número de llamadas.",
      "functionBreakPointInputAriaLabel": "Escriba el punto de interrupción de función.",
      "functionBreakpoint": "Punto de interrupción de la función",
      "functionBreakpointExpressionPlaceholder": "Interrumpir cuando la expresión se evalúe como true",
      "functionBreakpointHitCountPlaceholder": "Interrumpir cuando se alcance el número de llamadas",
      "functionBreakpointPlaceholder": "Función donde interrumpir",
      "functionBreakpointUnsupported": "Este tipo de depuración no admite puntos de interrupción en funciones",
      "functionBreakpointsNotSupported": "Este tipo de depuración no admite puntos de interrupción en funciones",
      "hitCount": "Número de llamadas: {0}",
      "instructionBreakpoint": "Punto de interrupción de instrucción",
      "instructionBreakpointAtAddress": "Punto de interrupción de instrucción en la dirección {0}",
      "instructionBreakpointUnsupported": "Este tipo de depuración no admite los puntos de interrupción de instrucción",
      "logMessage": "Mensaje de registro: {0}",
      "miDataBreakpoint": "&&Punto de interrupción de datos...",
      "miDisableAllBreakpoints": "&&Deshabilitar todos los puntos de interrupción",
      "miEnableAllBreakpoints": "&&Habilitar todos los puntos de interrupción",
      "miFunctionBreakpoint": "Punto de interrupción de &&función...",
      "miRemoveAllBreakpoints": "Quitar &&todos los puntos de interrupción",
      "read": "Lectura",
      "reapplyAllBreakpoints": "Volver a aplicar todos los puntos de interrupción",
      "removeAllBreakpoints": "Quitar todos los puntos de interrupción",
      "removeBreakpoint": "Quitar punto de interrupción",
      "selectBreakpointMode": "Seleccionar modo de punto de interrupción",
      "triggeredBy": "Alcanzar después del punto de interrupción: {0}",
      "unverifiedBreakpoint": "Punto de interrupción no comprobado",
      "unverifiedExceptionBreakpoint": "Punto de interrupción de excepción no comprobado",
      "unverifiedLogpoint": "Punto de registro no comprobado",
      "write": "Escritura"
    },
    "vs/workbench/contrib/debug/browser/breakpointWidget": {
      "bpMode": "Modo",
      "breakpointType": "Tipo de punto de interrupción",
      "breakpointWidgetExpressionPlaceholder": "Interrumpir cuando la expresión se evalúa como true. ''{0}'' para aceptar, ''{1}'' para cancelar.",
      "breakpointWidgetHitCountPlaceholder": "Interrumpir cuando se cumple la condición de recuento de llamadas. ''{0}'' para aceptar, ''{1}'' para cancelar.",
      "breakpointWidgetLogMessagePlaceholder": "Mensaje para registrar cuando se alcanza el punto de interrupción. Las expresiones dentro de {} se interpolan. ''{0}'' para aceptar, ''{1}'' para cancelar.",
      "expression": "Expresión",
      "hitCount": "Número de llamadas",
      "logMessage": "Mensaje de registro",
      "noBpSource": "No se pudo cargar el origen.",
      "noTriggerByBreakpoint": "Ninguno",
      "ok": "Aceptar",
      "selectBreakpoint": "Seleccionar punto de interrupción",
      "triggerByLoading": "Cargando...",
      "triggeredBy": "Esperar al punto de interrupción"
    },
    "vs/workbench/contrib/debug/browser/callStackEditorContribution": {
      "focusedStackFrameLineHighlight": "Color de fondo para el resaltado de línea en la posición enfocada del marco de pila.",
      "topStackFrameLineHighlight": "Color de fondo para el resaltado de línea en la posición superior del marco de pila. "
    },
    "vs/workbench/contrib/debug/browser/callStackView": {
      "callStackAriaLabel": "Pila de llamadas de la depuración",
      "collapse": "Contraer todo",
      "loadAllStackFrames": "Cargar más marcos de pila",
      "paused": "En pausa",
      "pausedOn": "En pausa en {0}",
      "restartFrame": "Reiniciar marco",
      "running": "En ejecución",
      "session": "Sesión",
      "sessionLabel": "Sesión {0} {1}",
      "showMoreAndOrigin": "Mostrar {0} más: {1}",
      "showMoreStackFrames": "Mostrar {0} marcos de pila más",
      "showMoreStackFrames2": "Ver más marcos de pila",
      "stackFrameAriaLabel": "Marco de pila {0}, línea {1}, {2}",
      "threadAriaLabel": "Subproceso {0} {1}"
    },
    "vs/workbench/contrib/debug/browser/callStackWidget": {
      "failedToLoadFrames": "No se pudieron cargar los marcos de pila: {0}",
      "goToFile": "Abrir archivo",
      "stackFrameLocation": "Línea {0} columna {1}",
      "stackTrace": "Seguimiento de la pila",
      "stackTraceLabel": "{0}, línea {1} en {2}"
    },
    "vs/workbench/contrib/debug/browser/debug.contribution": {
      "SetNextStatement": "Establecer la instrucción siguiente",
      "allowBreakpointsEverywhere": "Permite establecer puntos de interrupción en cualquier archivo.",
      "always": "Mostrar siempre la depuración en la barra de estado",
      "breakWhenValueChanges": "Interrumpir al cambiar el valor",
      "breakWhenValueIsAccessed": "Interrumpir al acceder al valor",
      "breakWhenValueIsRead": "Interrumpir al leer el valor",
      "breakpoints": "Puntos de interrupción",
      "callStack": "Pila de llamadas",
      "cancel": "Cancele la depuración.",
      "closeReadonlyTabsOnEnd": "Al final de una sesión de depuración, se cerrarán todas las pestañas de solo lectura asociadas a esa sesión.",
      "copyStackTrace": "Copiar pila de llamadas",
      "copyValue": "Copiar valor",
      "debug.autoExpandLazyVariables": "Controla si el depurador resuelve y expande automáticamente las variables que se resuelven de forma diferida, como los captadores.",
      "debug.autoExpandLazyVariables.auto": "Cuando está en modo optimizado para lectores de pantalla, expanda automáticamente las variables diferidas.",
      "debug.autoExpandLazyVariables.off": "Nunca expanda automáticamente las variables diferidas.",
      "debug.autoExpandLazyVariables.on": "Expanda siempre automáticamente las variables diferidas.",
      "debug.confirmOnExit": "Controla si se debe confirmar cuándo se cierra la ventana si hay sesiones de depuración activas.",
      "debug.confirmOnExit.always": "Confirmar siempre si hay sesiones de depuración.",
      "debug.confirmOnExit.never": "No confirmar nunca.",
      "debug.console.acceptSuggestionOnEnter": "Controla si las sugerencias deben ser aceptadas al entrar en la consola de depuración. La tecla Entrar también se utiliza para evaluar lo que se escribe en la consola de depuración.",
      "debug.console.closeOnEnd": "Controla si la consola de depuración debe cerrarse automáticamente cuando finaliza la sesión de depuración.",
      "debug.console.collapseIdenticalLines": "Controla si la consola de depuración debe contraer las líneas idénticas y mostrar un número de repeticiones con un distintivo.",
      "debug.console.fontFamily": "Controla la familia de fuentes en la consola de depuración.",
      "debug.console.fontSize": "Controla el tamaño de fuente en píxeles en la consola de depuración.",
      "debug.console.historySuggestions": "Controla si la Consola de depuración debe sugerir la entrada escrita previamente.",
      "debug.console.lineHeight": "Controla la altura de la línea en píxeles en la consola de depuración. Use 0 para calcular la altura de la línea del tamaño de fuente.",
      "debug.console.maximumLines": "Controla el número máximo de líneas en la Consola de depuración.",
      "debug.console.wordWrap": "Controla si las líneas deben ajustarse en la consola de depuración.",
      "debug.disassemblyView.showSourceCode": "Mostrar código fuente en vista de desensamblado.",
      "debug.enableStatusBarColor": "Color de la barra de estado cuando el depurador está activo.",
      "debug.focusEditorOnBreak": "Controla si el editor debe centrarse cuando se interrumpe el depurador.",
      "debug.focusWindowOnBreak": "Controla si la ventana del área de trabajo debe centrarse cuando se interrumpe el depurador.",
      "debug.gutterMiddleClickAction.conditionalBreakpoint": "Agregar punto de interrupción condicional.",
      "debug.gutterMiddleClickAction.logpoint": "Agregar punto de registro.",
      "debug.gutterMiddleClickAction.none": "No realizar ninguna acción.",
      "debug.gutterMiddleClickAction.triggeredBreakpoint": "Agregar punto de interrupción desencadenado.",
      "debug.hideLauncherWhileDebugging": "Ocultar el control \"Iniciar depuración\" en la barra de título de la vista \"Ejecutar y depurar\" mientras la depuración está activa. Solo es relevante cuando {0} no es \"docked\".",
      "debug.hideSlowPreLaunchWarning": "Oculta la advertencia que se muestra cuando un objeto \"preLaunchTask\" se ha estado ejecutando durante un tiempo.",
      "debug.onTaskErrors": "Controla qué hacer cuando se encuentran errores después de ejecutar preLaunchTask.",
      "debug.saveBeforeStart": "Controla qué editores deben guardarse antes de iniciar una sesión de depuración.",
      "debug.saveBeforeStart.allEditorsInActiveGroup": "Guarde todos los editores del grupo activo antes de iniciar una sesión de depuración.",
      "debug.saveBeforeStart.nonUntitledEditorsInActiveGroup": "Guarde todos los editores del grupo activo, excepto aquellos que no tengan título, antes de iniciar una sesión de depuración.",
      "debug.saveBeforeStart.none": "No guarde ningún editor antes de iniciar una sesión de depuración.",
      "debug.terminal.clearBeforeReusing": "Antes de iniciar una nueva sesión de depuración en un terminal integrado o externo, borre el terminal.",
      "debugAnyway": "Ignore los errores de la tarea e inicie la depuración.",
      "debugCategory": "Depurar",
      "debugConfigurationTitle": "Depurar",
      "debugPanel": "Consola de depuración",
      "debugToolBar.commandCenter": "'(Experimental)' Muestra la barra de herramientas de depuración en el centro de comandos.",
      "debugToolBar.docked": "Mostrar la barra de herramientas de depuración solo en vistas de depuración.",
      "debugToolBar.floating": "Muestra la barra de herramientas de depuración en todas las vistas.",
      "debugToolBar.hidden": "No mostrar la barra de herramientas de depuración.",
      "disassembly": "Desensamblado",
      "editWatchExpression": "Editar expresión",
      "gutterMiddleClickAction": "Controla la acción que se va a realizar al hacer clic en el medianil del editor con el botón central del mouse.",
      "inlineBreakpoint": "Punto de interrupción insertado",
      "inlineValues": "Muestre valores de variable en línea en el editor durante la depuración.",
      "inlineValues.focusNoScroll": "Muestra los valores de variable insertados en el editor durante la depuración cuando el lenguaje admite ubicaciones de valores insertados.",
      "inlineValues.off": "No muestra nunca los valores de variable en línea en el editor durante la depuración.",
      "inlineValues.on": "Muestra siempre valores de variable en línea en el editor durante la depuración.",
      "jumpToCursor": "Saltar al cursor",
      "launch": "Configuración de lanzamiento de depuración global. Puede usarse como alternativa a \"launch.json\" que se comparte a través de áreas de trabajo.",
      "loadedScripts": "Scripts Cargados",
      "mRun": "&&Ejecutar",
      "miAddConfiguration": "A&&gregar configuración...",
      "miContinue": "&&Continuar",
      "miInlineBreakpoint": "P&&unto de interrupción en línea",
      "miInstallAdditionalDebuggers": "&&Instalar los depuradores adicionales...",
      "miNewBreakpoint": "&&Nuevo punto de interrupción",
      "miRestart Debugging": "&&Reiniciar depuración",
      "miRun": "Ejecutar &&sin depuración",
      "miStartDebugging": "I&&niciar depuración",
      "miStepInto": "&&Depurar paso a paso por instrucciones",
      "miStepOut": "Depurar paso a paso para &&salir",
      "miStepOver": "Depurar paso a paso por proce&&dimientos",
      "miStopDebugging": "&&Detener depuración",
      "miToggleBreakpoint": "Alternar punto de interrupción",
      "miToggleDebugConsole": "Consola de de&&puración",
      "miViewRun": "&&Ejecutar",
      "never": "Nunca mostrar debug en la barra de estado",
      "onFirstSessionStart": "Mostrar debug en la barra de estado solamente después del primero uso de debug",
      "openDebug": "Controla cuándo debe abrirse la vista de depuración.",
      "openExplorerOnEnd": "Abra automáticamente la vista de explorador al final de una sesión de depuración.",
      "prompt": "Preguntar al usuario.",
      "removeWatchExpression": "Quitar expresión",
      "restartFrame": "Reiniciar marco",
      "run": "Ejecutar o depurar...",
      "run and debug": "Ejecución y depuración",
      "runMenu": "Ejecutar",
      "setValue": "Establecer valor",
      "showBreakpointsInOverviewRuler": "Controla si los puntos de interrupción deben mostrarse en la regla de información general.",
      "showErrors": "Muestre la vista Problemas y no inicie la depuración.",
      "showInStatusBar": "Controla cuándo debe estar visible la barra de estado de depuración.",
      "showInlineBreakpointCandidates": "Controla si se deben mostrar las decoraciones de candidatos de puntos de interrupción de líneas en el editor mientras se realiza la depuración.",
      "showSubSessionsInToolBar": "Controla si las subsesiones de depuración se muestran en la barra de herramientas de depuración. Cuando esta opción es false, el comando de parada de una subsesión detendrá también la sesión principal.",
      "showVariableTypes": "Mostrar el tipo de variable en el panel de variables durante la sesión de depuración",
      "startDebugPlaceholder": "Escriba el nombre de la configuración de lanzamiento que se ejecutará.",
      "startDebuggingHelp": "Iniciar depuración",
      "tasksQuickAccessHelp": "Mostrar todas las consolas de depuración",
      "tasksQuickAccessPlaceholder": "Escriba el nombre de una consola de depuración para abrir.",
      "terminateThread": "Terminar hilo de ejecución",
      "toolBarLocation": "Controla la ubicación de la barra de herramientas de depuración. Puede ser \"flotante\" en todas las vistas, \"acoplado\" en la vista de depuración, \"commandCenter\" (requiere {0}) o \"oculta\".",
      "variables": "Variables",
      "viewMemory": "Ver datos binarios",
      "watch": "Inspección"
    },
    "vs/workbench/contrib/debug/browser/debugActionViewItems": {
      "addConfigTo": "Agregar configuración ({0})...",
      "addConfiguration": "Agregar configuración...",
      "commentLabelWithKeybinding": "{0}, use ({1}) para la ayuda de accesibilidad del editor",
      "commentLabelWithKeybindingNoKeybinding": "{0}, ejecute el comando Abrir ayuda de accesibilidad, que actualmente no se puede desencadenar mediante un enlace de teclado.",
      "debugLaunchConfigurations": "Configuraciones de inicio de depuración",
      "debugSession": "Sesión de depuración",
      "noConfigurations": "No hay configuraciones"
    },
    "vs/workbench/contrib/debug/browser/debugAdapterManager": {
      "CouldNotFindLanguage": "No tiene una extensión para depurar {0}. ¿Deberíamos encontrar una extensión de {0} en el Marketplace?",
      "debugName": "Nombre de la configuración; aparece en el menú desplegable de la configuración de inicio.",
      "debugNoType": "El 'tipo' de depurador no se puede omitir y debe ser de tipo 'cadena'. ",
      "debugPostDebugTask": "Tarea que se ejecutará después de terminar la sesión de depuración.",
      "debugPrelaunchTask": "Tarea que se va a ejecutar antes de iniciarse la sesión de depuración.",
      "debugServer": "Solo para el desarrollo de extensiones de depuración: si se especifica un puerto, VS Code intenta conectarse a un adaptador de depuración que se ejecuta en modo servidor",
